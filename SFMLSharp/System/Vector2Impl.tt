<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ assembly name="System.Core" #>
<#
(string name, string type, bool unsigned)[] vector2 = new (string, string, bool)[]
{
	("Vector2F", "float", false),
	("Vector2I", "int", false),
	("Vector2U", "uint", true)
};
#>
using System.Diagnostics.CodeAnalysis;
using System.Drawing;
using System.Numerics;
using System.Runtime.Versioning;

namespace SFML.System
{
<#
foreach ((string name, string type, bool unsigned) in vector2)
{
#>
	/// <summary>
	///   Represents a 2-component vectors of <see cref="<#= type #>" />.
	/// </summary>
	public partial struct <#= name #> :
		IVector2<<#= type #>>,
		IReadOnlyVector2<<#= type #>>,
		IEquatable<<#= name #>>,
		IFormattable
	{
		#region Fields & Properties

		/// <inheritdoc cref="IVector2{T}.X"/>
		public <#= type #> X;
		/// <inheritdoc cref="IVector2{T}.Y"/>
		public <#= type #> Y;

		<#= type #> IVector2<<#= type #>>.X { get => X; set => X = value; }
		<#= type #> IVector2<<#= type #>>.Y { get => Y; set => Y = value; }

		<#= type #> IReadOnlyVector2<<#= type #>>.X => X;
		<#= type #> IReadOnlyVector2<<#= type #>>.Y => Y;

		#endregion

		#region Static Properties

		public static <#= name #> Zero => default;
		public static <#= name #> UnitX => new(1, 0);
		public static <#= name #> UnitY => new(0, 1);
		public static <#= name #> One => new(1);

		#endregion

		#region Constructors

		/// <include file='Vector.xml' path='doc/vector[@name="Constructs1"]'/>
		public <#= name #>(<#= type #> value) : this(value, value) { }

		/// <include file='Vector.xml' path='doc/vector[@name="Constructs1"]'/>
		public <#= name #>(IReadOnlyVector2<<#= type #>> value) : this(value.X, value.Y) { }

		/// <include file='Vector.xml' path='doc/vector[@name="Constructs2"]'/>
		public <#= name #>(<#= type #> x, <#= type #> y)
		{
			X = x;
			Y = y;
		}

		#endregion

		#region Static Methods
<#
	if (!unsigned)
	{
#>

		///// <inheritdoc cref="operator -(<#= name #>)"/>
		//public static <#= name #> Negate(<#= name #> value)
		//{
		//	return -value;
		//}
<#
	}
#>

		///// <inheritdoc cref="operator +(<#= name #>, <#= name #>)"/>
		//public static <#= name #> Add(<#= name #> left, <#= name #> right)
		//{
		//	return left + right;
		//}
		
		///// <inheritdoc cref="operator -(<#= name #>, <#= name #>)"/>
		//public static <#= name #> Subtract(<#= name #> left, <#= name #> right)
		//{
		//	return left - right;
		//}
		
		///// <inheritdoc cref="operator *(<#= name #>, <#= name #>)"/>
		//public static <#= name #> Multiply(<#= name #> left, <#= name #> right)
		//{
		//	return left * right;
		//}
		
		///// <inheritdoc cref="operator /(<#= name #>, <#= name #>)"/>
		//public static <#= name #> Divide(<#= name #> left, <#= name #> right)
		//{
		//	return left / right;
		//}

		#endregion

		#region Interface Implementations

		public bool Equals(<#= name #> other)
		{
			return X.Equals(other.X) && Y.Equals(other.Y);
		}

		public override bool Equals([NotNullWhen(true)] object? obj)
		{
			return obj is <#= name #> other && Equals(other);
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(X, Y);
		}

		public string ToString(string? format, IFormatProvider? formatProvider)
		{
			return this.Format(format, formatProvider);
		}

		#endregion

		#region Operators

		public static bool operator ==(<#= name #> left, <#= name #> right)
		{
			return left.X == right.X && left.Y == right.Y;
		}

		public static bool operator !=(<#= name #> left, <#= name #> right)
		{
			return left.X != right.X || left.Y != right.Y;
		}
<#
	if (!unsigned)
	{
#>

		/// <include file='Vector.xml' path='doc/vector[@name="Negate"]'/>
		public static <#= name #> operator -(<#= name #> value)
		{
			return new(-value.X, -value.Y);
		}
<#
	}
#>

		/// <include file='Vector.xml' path='doc/vector[@name="Add"]'/>
		public static <#= name #> operator +(<#= name #> left, <#= name #> right)
		{
			return new(
				left.X + right.X,
				left.Y + right.Y);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Subtract"]'/>
		public static <#= name #> operator -(<#= name #> left, <#= name #> right)
		{
			return new(
				left.X - right.X,
				left.Y - right.Y);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Multiply"]'/>
		public static <#= name #> operator *(<#= name #> left, <#= name #> right)
		{
			return new(
				left.X * right.X,
				left.Y * right.Y);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Multiply"]'/>
		public static <#= name #> operator *(<#= name #> left, <#= type #> right)
		{
			return new(
				left.X * right,
				left.Y * right);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Multiply"]'/>
		public static <#= name #> operator *(<#= type #> left, <#= name #> right)
		{
			return right * left;
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Divide"]'/>
		public static <#= name #> operator /(<#= name #> left, <#= name #> right)
		{
			return new(
				left.X / right.X,
				left.Y / right.Y);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Divide"]'/>
		public static <#= name #> operator /(<#= name #> left, <#= type #> right)
		{
			return new(
				left.X / right,
				left.Y / right);
		}

		#endregion

		#region Cast Operators

		public static implicit operator (<#= type #>, <#= type #>)(<#= name #> value)
		{
			return (value.X, value.Y);
		}
		public static implicit operator <#= name #>((<#= type #> x, <#= type #> y) value)
		{
			return new(value.x, value.y);
		}

		[RequiresPreviewFeatures]
		public static implicit operator Vector2<<#= type #>>(<#= name #> value)
		{
			return new(value.X, value.Y);
		}
		[RequiresPreviewFeatures]
		public static implicit operator <#= name #>(Vector2<<#= type #>> value)
		{
			return new(value.X, value.Y);
		}

<#
	foreach ((string name, string type, bool unsigned) toConvert in vector2)
	{
		if (toConvert.name != name)
		{
		string castTo = type == "float" ? string.Empty : $"({type})";
#>
		public static explicit operator <#= name #>(<#= toConvert.name #> value)
		{
			return new(<#= castTo #>value.X, <#= castTo #>value.Y);
		}
<#
		}
	}

	string castToType = type == "float" ? string.Empty : $"({type})";
#>

		public static explicit operator Vector2(<#= name #> value)
		{
			return new(value.X, value.Y);
		}
		public static explicit operator <#= name #>(Vector2 value)
		{
			return new(<#= castToType #>value.X, <#= castToType #>value.Y);
		}

		public static explicit operator PointF(<#= name #> value)
		{
			return new(value.X, value.Y);
		}
		public static explicit operator <#= name #>(PointF value)
		{
			return new(<#= castToType #>value.X, <#= castToType #>value.Y);
		}

		public static explicit operator SizeF(<#= name #> value)
		{
			return new(value.X, value.Y);
		}
		public static explicit operator <#= name #>(SizeF value)
		{
			return new(<#= castToType #>value.Width, <#= castToType #>value.Height);
		}
<#
	string castFromType = "(int)";

	if (type == "int")
	{
		castFromType = string.Empty;
		castToType = string.Empty;
	}
	else if (type == "float")
	{
		castToType = string.Empty;
	}
	else
	{
		castToType = $"({type})";
	}
#>

		public static explicit operator Point(<#= name #> value)
		{
			return new(<#= castFromType #>value.X, <#= castFromType #>value.Y);
		}
		public static explicit operator <#= name #>(Point value)
		{
			return new(<#= castToType #>value.X, <#= castToType #>value.Y);
		}

		public static explicit operator Size(<#= name #> value)
		{
			return new(<#= castFromType #>value.X, <#= castFromType #>value.Y);
		}
		public static explicit operator <#= name #>(Size value)
		{
			return new(<#= castToType #>value.Width, <#= castToType #>value.Height);
		}

		#endregion
	}

<#
}
#>
}
