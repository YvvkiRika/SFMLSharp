<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ assembly name="System.Core" #>
<#
(string name, string type, bool unsigned)[] vector3 = new (string, string, bool)[]
{
	("Vector3F", "float", false),
};
#>
using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using System.Runtime.Versioning;

namespace SFML.System
{
<#
foreach ((string name, string type, bool unsigned) in vector3)
{
#>
	/// <summary>
	///   Represents a 3-component vectors of <see cref="<#= type #>" />.
	/// </summary>
	public partial struct <#= name #> :
		IVector3<<#= type #>>,
		IReadOnlyVector3<<#= type #>>,
		IEquatable<<#= name #>>,
		IFormattable
	{
		#region Fields & Properties

		/// <inheritdoc cref="IVector2{T}.X"/>
		public <#= type #> X;
		/// <inheritdoc cref="IVector2{T}.Y"/>
		public <#= type #> Y;
		/// <inheritdoc cref="IVector3{T}.Z"/>
		public <#= type #> Z;

		<#= type #> IVector2<<#= type #>>.X { get => X; set => X = value; }
		<#= type #> IVector2<<#= type #>>.Y { get => Y; set => Y = value; }
		<#= type #> IVector3<<#= type #>>.Z { get => Z; set => Z = value; }

		<#= type #> IReadOnlyVector2<<#= type #>>.X => X;
		<#= type #> IReadOnlyVector2<<#= type #>>.Y => Y;
		<#= type #> IReadOnlyVector3<<#= type #>>.Z => Z;

		#endregion

		#region Static Properties

		public static <#= name #> Zero => default;
		public static <#= name #> UnitX => new(1, 0, 0);
		public static <#= name #> UnitY => new(0, 1, 0);
		public static <#= name #> UnitZ => new(0, 0, 1);
		public static <#= name #> One => new(1);

		#endregion

		#region Constructors

		/// <include file='Vector.xml' path='doc/vector[@name="Constructs1"]'/>
		public <#= name #>(<#= type #> value) : this(value, value, value) { }

		/// <include file='Vector.xml' path='doc/vector[@name="Constructs1"]'/>
		public <#= name #>(IReadOnlyVector3<<#= type #>> value) : this(value.X, value.Y, value.Z) { }

		/// <include file='Vector.xml' path='doc/vector[@name="Constructs3From2"]'/>
		public <#= name #>(IReadOnlyVector2<<#= type #>> value, <#= type #> z) : this(value.X, value.Y, z) { }

		/// <include file='Vector.xml' path='doc/vector[@name="Constructs3With2"]'/>
		public <#= name #>(<#= type #> x, IReadOnlyVector2<<#= type #>> value) : this(x, value.X, value.Y) { }

		/// <include file='Vector.xml' path='doc/vector[@name="Constructs3"]'/>
		public <#= name #>(<#= type #> x, <#= type #> y, <#= type #> z)
		{
			X = x;
			Y = y;
			Z = z;
		}

		#endregion

		#region Static Methods
<#
	if (!unsigned)
	{
#>

		///// <inheritdoc cref="operator -(<#= name #>)"/>
		//public static <#= name #> Negate(<#= name #> value)
		//{
		//	return -value;
		//}
<#
	}
#>

		///// <inheritdoc cref="operator +(<#= name #>, <#= name #>)"/>
		//public static <#= name #> Add(<#= name #> left, <#= name #> right)
		//{
		//	return left + right;
		//}
		
		///// <inheritdoc cref="operator -(<#= name #>, <#= name #>)"/>
		//public static <#= name #> Subtract(<#= name #> left, <#= name #> right)
		//{
		//	return left - right;
		//}
		
		///// <inheritdoc cref="operator *(<#= name #>, <#= name #>)"/>
		//public static <#= name #> Multiply(<#= name #> left, <#= name #> right)
		//{
		//	return left * right;
		//}

		///// <inheritdoc cref="operator /(<#= name #>, <#= name #>)"/>
		//public static <#= name #> Divide(<#= name #> left, <#= name #> right)
		//{
		//	return left / right;
		//}

		#endregion

		#region Interface Implementations

		public bool Equals(<#= name #> other)
		{
			return X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);
		}

		public override bool Equals([NotNullWhen(true)] object? obj)
		{
			return obj is <#= name #> other && Equals(other);
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(X, Y, Z);
		}

		public string ToString(string? format, IFormatProvider? formatProvider)
		{
			return this.Format(format, formatProvider);
		}

		#endregion

		#region Operators

		public static bool operator ==(<#= name #> left, <#= name #> right)
		{
			return left.X == right.X && left.Y == right.Y && left.Z == right.Z;
		}

		public static bool operator !=(<#= name #> left, <#= name #> right)
		{
			return left.X != right.X || left.Y != right.Y || left.Z != right.Z;
		}
<#
	if (!unsigned)
	{
#>

		/// <include file='Vector.xml' path='doc/vector[@name="Negate"]'/>
		public static <#= name #> operator -(<#= name #> value)
		{
			return new(-value.X, -value.Y, -value.Z);
		}
<#
	}
#>

		/// <include file='Vector.xml' path='doc/vector[@name="Add"]'/>
		public static <#= name #> operator +(<#= name #> left, <#= name #> right)
		{
			return new(
				left.X + right.X,
				left.Y + right.Y,
				left.Z + right.Z);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Subtract"]'/>
		public static <#= name #> operator -(<#= name #> left, <#= name #> right)
		{
			return new(
				left.X - right.X,
				left.Y - right.Y,
				left.Z - right.Z);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Multiply"]'/>
		public static <#= name #> operator *(<#= name #> left, <#= name #> right)
		{
			return new(
				left.X * right.X,
				left.Y * right.Y,
				left.Z * right.Z);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Multiply"]'/>
		public static <#= name #> operator *(<#= name #> left, <#= type #> right)
		{
			return new(
				left.X * right,
				left.Y * right,
				left.Z * right);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Multiply"]'/>
		public static <#= name #> operator *(<#= type #> left, <#= name #> right)
		{
			return right * left;
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Divide"]'/>
		public static <#= name #> operator /(<#= name #> left, <#= name #> right)
		{
			return new(
				left.X / right.X,
				left.Y / right.Y,
				left.Z / right.Z);
		}

		/// <include file='Vector.xml' path='doc/vector[@name="Divide"]'/>
		public static <#= name #> operator /(<#= name #> left, <#= type #> right)
		{
			return new(
				left.X / right,
				left.Y / right,
				left.Z / right);
		}

		#endregion

		#region Cast Operators

		public static implicit operator (<#= type #>, <#= type #>, <#= type #>)(<#= name #> value)
		{
			return (value.X, value.Y, value.Z);
		}
		public static implicit operator <#= name #>((<#= type #> x, <#= type #> y, <#= type #> z) value)
		{
			return new(value.x, value.y, value.z);
		}

		[RequiresPreviewFeatures]
		public static implicit operator Vector3<<#= type #>>(<#= name #> value)
		{
			return new(value.X, value.Y, value.Z);
		}
		[RequiresPreviewFeatures]
		public static implicit operator <#= name #>(Vector3<<#= type #>> value)
		{
			return new(value.X, value.Y, value.Z);
		}

<#
	foreach ((string name, string type, bool unsigned) toConvert in vector3)
	{
		if (toConvert.name != name)
		{
		string castTo = type == "float" ? string.Empty : $"({type})";
#>
		public static explicit operator <#= toConvert.name #>(<#= name #> value)
		{
			return new(<#= castTo #>value.X, <#= castTo #>value.Y, <#= castTo #>value.Z);
		}
<#
		}
	}

	string castToType = type == "float" ? string.Empty : $"({type})";
#>
		public static explicit operator Vector3(<#= name #> value)
		{
			return new(value.X, value.Y, value.Z);
		}
		public static explicit operator <#= name #>(Vector3 value)
		{
			return new(<#= castToType #>value.X, <#= castToType #>value.Y, <#= castToType #>value.Z);
		}

		#endregion
	}

<#
}
#>
}
